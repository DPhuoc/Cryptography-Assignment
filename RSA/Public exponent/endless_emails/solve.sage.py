

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_8 = Integer(8)
n=[]
e=_sage_const_3 
c=[]
with open("output.txt",'r') as f:
	for lines in f:
		if lines[_sage_const_0 ] == 'n': n.append(int(lines.strip()[_sage_const_3 :]))
		elif lines[_sage_const_0 ] == 'c': c.append(int(lines.strip()[_sage_const_3 :]))
print(len(n))
print(len(c))

N=prod(n)
n_min=min(n)
b1=vector([(n_min**i)*c[i] for i in range(e+_sage_const_1 )]+[_sage_const_1 /(e+_sage_const_1 )])
b2=vector([N]+[_sage_const_0 ]*_sage_const_4 )
b3=vector([_sage_const_0 ]*_sage_const_1 +[(n_min**_sage_const_1 )*N]+[_sage_const_0 ]*_sage_const_3 )
b4=vector([_sage_const_0 ]*_sage_const_2 +[(n_min**_sage_const_2 )*N]+[_sage_const_0 ]*_sage_const_2 )
b5=vector([_sage_const_0 ]*_sage_const_3 +[(n_min**_sage_const_3 )*N]+[_sage_const_0 ]*_sage_const_1 )

print(b1.parent())
a=matrix([b1,b2,b3,b4,b5])
print(a.parent())
tmp=a.LLL()
print(tmp[_sage_const_0 ])

def linearPaddingHastads(cArray,nArray,aArray,bArray,e=_sage_const_3 ,eps=_sage_const_1 /_sage_const_8 ):
    """
    Performs Hastads attack on raw RSA with no padding.
    This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])
    Where they are all encryptions of the same message.
    cArray = Ciphertext Array
    nArray = Modulus Array
    aArray = Array of 'slopes' for the linear padding
    bArray = Array of 'y-intercepts' for the linear padding
    e = public exponent
    """
    if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e):
        for i in range(e):
            cArray[i] = Integer(cArray[i])
            nArray[i] = Integer(nArray[i])
            aArray[i] = Integer(aArray[i])
            bArray[i] = Integer(bArray[i])
        TArray = [-_sage_const_1 ]*e
        for i in range(e):
            arrayToCRT = [_sage_const_0 ]*e
            arrayToCRT[i] = _sage_const_1 
            TArray[i] = crt(arrayToCRT,nArray)
        P = PolynomialRing(Zmod(prod(nArray)), names=('x',)); (x,) = P._first_ngens(1)
        gArray = [-_sage_const_1 ]*e
        for i in range(e):
            gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i],e) - cArray[i])
        g = sum(gArray)
        g = g.monic()
        # Use Sage's inbuilt coppersmith method
        roots = g.small_roots(epsilon=eps)
        if(len(roots)== _sage_const_0 ):
            print("No Solutions found")
            return -_sage_const_1 
        return roots[_sage_const_0 ]

    else:
        print("CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length," +
         "and the same size as the public exponent")



print(linearPaddingHastads(c[:_sage_const_3 ],n[:_sage_const_3 ],[_sage_const_1 ,_sage_const_1 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]))

